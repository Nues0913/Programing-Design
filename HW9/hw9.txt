第一題程式碼解釋:




第二題問題回答:


第一小題:
1.175494350822287507968736537222245677818665556772087521508751706278417259454727172851560500000000000000000000000000000000e-38f
不是the smallest floating point number
the smallest floating point number應為
1.1754943508222875079687365372222456778186655567720875215087517062784172594547271728515625000000000000e-38f
其中兩者的小數點第87位數字不同


第二小題:
0.0的bit pattern為
00000000000000000000000000000000


第三小題:
#include<stdio.h>
int main(){
    float f1 = 1.175494350822287507968736537222245677818665556772087521508751706278417259454727172851560500000000000000000000000000000000e-38f;
    float f2 = 1.175494350822287500e-38f;
    /*
    float的精度大約到小數點後6~7位，f1與f2的精度只到1.1754943，
    轉成二進位都相等於00000000100000000000000000000000，
    所以f1與f2被視為相等
    */
    if( f1==f2 ) { printf("%.100e = %.100e", f1, f2);
    } else { printf("%.100e != %.100e", f1, f2); }
    //result: 1.1754943508222875079687365372222456778186655567720875215087517062784172594547271728515625000000000000e-38 = 1.1754943508222875079687365372222456778186655567720875215087517062784172594547271728515625000000000000e-38
}